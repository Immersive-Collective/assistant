<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">
  <title>Assistant â€¢ Chat</title>

  <link rel="stylesheet" href="{{ url_for('static', filename='css/assistant.css') }}">
</head>
<body>

  <div class="wrap">

    <div class="topline">
      <span id="healthDot" class="dot"></span>
      <span id="healthText">Checking modelâ€¦</span>

      <span class="meta" style="margin-left:auto;">
        <label class="model-label">
          Model:
          <select id="modelSelect" class="model-select"></select>
        </label>
        <button id="themeToggle" class="theme-toggle">ðŸŒ™</button>
        <span id="ctxText"></span>
      </span>
    </div>


    <div id="chat" class="chat" aria-live="polite"></div>

    <div class="row">
      <div class="box">
        <textarea id="prompt" placeholder="Type a messageâ€¦ (Enter = send, Shift+Enter = newline)"></textarea>
        <button id="sendBtn">Send</button>
      </div>
    </div>

    {% if show_tech %}
    <div class="panel" style="margin:10px;">
      <div class="meta"><b>Advanced</b> â€” temp/top-p/max tokens</div>
      <div style="display:flex; gap:10px; margin-top:8px;">
        <label class="meta">Max tokens <input id="maxTokens" type="number" min="1" max="4096" value="512"></label>
        <label class="meta">Temperature <input id="temperature" type="number" step="0.1" min="0" max="2" value="0.6"></label>
        <label class="meta">Top-p <input id="topP" type="number" step="0.05" min="0" max="1" value="0.9"></label>
      </div>
    </div>
    {% endif %}
  </div>

  <script>
    const $ = s => document.querySelector(s);
    const chat = $('#chat'); const sendBtn = $('#sendBtn'); const promptEl = $('#prompt');
    let history = [];

    function addMsg(role, text){
      const wrap = document.createElement('div'); 
      wrap.className = 'msg ' + (role === 'user' ? 'user' : 'asst');

      const pre = document.createElement('div'); 
      pre.className = 'pre'; 
      pre.textContent = text; 
      wrap.appendChild(pre);

      // Add timestamp
      const ts = document.createElement('div');
      ts.className = 'ts';
      ts.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      wrap.appendChild(ts);

      chat.appendChild(wrap); 
      chat.scrollTop = chat.scrollHeight;
    }


    async function health(){
      try {
        const r = await fetch('/llama/health', { cache: 'no-store' });
        const j = await r.json().catch(()=>({}));
        const ok = j && j.import_ok && j.resolved_exists;
        $('#healthDot').classList.toggle('live', !!ok);
        $('#healthText').textContent = ok ? 'Ready' : 'Unavailable';

        // populate models
        const select = $('#modelSelect');
        select.innerHTML = '';
        (j.discovered || []).forEach(m => {
          const opt = document.createElement('option');
          opt.value = m;
          opt.textContent = m.split('/').pop();

          if (j.resolved_path && j.resolved_path.endsWith(opt.textContent)) {
            opt.selected = true;
          }

          select.appendChild(opt);
        });
        $('#ctxText').textContent = (j?.cfg?.n_ctx !== undefined) ? ` â€¢ Ctx: ${j.cfg.n_ctx}` : '';
      } catch { $('#healthText').textContent = 'Unavailable'; }
    }

    async function switchModel(path){
      await fetch('/llama/switch', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-Admin-Token': '' },
        body: JSON.stringify({ model_path: path })
      });
      history = [];  // clear old conversation
      addMsg('asst', `ðŸ”„ Model switched to: ${path.split('/').pop()}`);
      await health();
    }


    async function send(){
      const text = promptEl.value.trim(); if (!text) return;
      history.push({ role: 'user', content: text }); addMsg('user', text); promptEl.value = ''; sendBtn.disabled = true;

      const body = { messages: history };
      try {
        const res = await fetch('/assistant', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        if (!res.ok || !res.body) { addMsg('asst', `Error: HTTP ${res.status}`); return; }
        const reader = res.body.getReader(); const decoder = new TextDecoder();
        let asstText = '';
        while (true) {
          const {done, value} = await reader.read(); if (done) break;
          const t = decoder.decode(value, {stream:true});
          asstText += t;
        }
        addMsg('asst', asstText);
        history.push({ role: 'assistant', content: asstText });
      } finally { sendBtn.disabled = false; }
    }

    $('#modelSelect').addEventListener('change', e => switchModel(e.target.value));
    promptEl.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' && !e.shiftKey){ e.preventDefault(); send(); } });
    sendBtn.addEventListener('click', send);

    const themeBtn = $('#themeToggle');
    const DB_NAME = 'assistantSettings';
    const STORE_NAME = 'prefs';

  // --- IndexedDB helpers ---
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = e => {
          e.target.result.createObjectStore(STORE_NAME);
        };
        req.onsuccess = e => resolve(e.target.result);
        req.onerror = e => reject(e);
      });
    }

    async function saveDB(key, value) {
      try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        tx.objectStore(STORE_NAME).put(value, key);
        return tx.complete;
      } catch (e) {
        console.warn('DB save failed', e);
      }
    }

    async function loadDB(key) {
      try {
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE_NAME, 'readonly');
          const req = tx.objectStore(STORE_NAME).get(key);
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject();
        });
      } catch {
        return null;
      }
    }

  // --- Theme handling ---
    async function applyTheme(theme) {
      document.documentElement.classList.toggle('light', theme === 'light');
      themeBtn.textContent = theme === 'light' ? 'ðŸŒž' : 'ðŸŒ™';
      localStorage.setItem('theme', theme);
      await saveDB('theme', theme);
    }

    async function loadTheme() {
    // Try localStorage first
      let theme = localStorage.getItem('theme');
      if (!theme) {
        theme = await loadDB('theme');
      }
      if (!theme) {
      theme = 'dark'; // default
    }
    applyTheme(theme);
  }

  themeBtn.addEventListener('click', async () => {
    const isLight = document.documentElement.classList.toggle('light');
    const theme = isLight ? 'light' : 'dark';
    themeBtn.textContent = isLight ? 'ðŸŒž' : 'ðŸŒ™';
    localStorage.setItem('theme', theme);
    await saveDB('theme', theme);
  });

  loadTheme();


  health();

</script>
</body>
</html>
